Decorator pattern

Този шаблон може да бъде използван за разширяването на функционалността на опеределен клас по времето на изпълнение на програмата, като 
запазва интерфейса му. Той е много подходящ, когато се следва Принципът за еднолична отговорност(Single responsibility principle),
 според който един клас трябва да е отговорен за една единствена операция.

Този вид шаблон може да се използва за добавяне на функционалност към определен обект динамично, без това да засяга другите инстанции на 
същия клас. Това се постига чрез създаването на нов клас Декоратор, който „обвива“ класа. Това лесно може да се представи с примера, 
“опаковане на подарък, слагане на подаръка в кутия, опаковане на кутията“. Създава се поредица от обекти, която започва с декоратор 
обектите, отговорни за новите функционалности, и завършва с оригиналния обект.

Декораторът е удобна алтернатива на наследяването. При наследяването добавянето на функционалност става при компилация и промените се 
отнасят зa всички инстанции на оригиналния клас. Декораторът от своя страна добавя функционалност към даден обект динамично т.е по време 
на изпълнение на програмата, без да променя неговата структура.

Имаме повече гъвкавост от колкото при статично наследяване. При някои обектно-ориентирани езици, създаването на класове по време на 
изпълнение е невъзможно и обикновено по време на компилация не може да се предвидят какви комбинации от нови функционалности ще са нужни.
Това би означавало да се създава нов клас за всяка възможна комбинация. Това може да доведе до създаването на много класове и да усложни
структурата на системата. Декораторите, от своя страна, са обекти, създадени по време на изпълнение на програмата и могат да се 
комбинират според всяка нужда.
Избягва поставянето на прекалено много свойства в класовете, които са по-високо в йерархията. Декораторът, както вече беше споменато, 
прибавя нужните функционалности и съответно исканите комбинации. Вместо да се предвидят и поддържат всички свойства и характеристики 
чрез сложна поредица от отделни класове, може да се създаде обикновен клас, към който последователно да се добавят свойства чрез 
декоратор класовете. Така даденото приложение не се усложнява с особености, от които няма нужда.
Декораторът и неговия компонент не са идентични. Декораторът е просто обвивка. От гледна точка на програмната логика, клас с добавен 
декоратор е различен от оригиналния клас. В този смисъл не може да се разчита на типа обект, когато се използват декоратори.
Наличието на много малки обекти. Дизайн, който използва декоратор, често съдържа множество малки обекти, които изглеждат по един и същи начин.
Тези обекти се различават по начина, по който са свързани помежду си, а не по класа им или по стойностите на техните променливи. Оттук идва 
и трудността при изучаването и разбирането им.